!function(e,t){"object"==typeof exports&&"object"==typeof module?module.exports=t():"function"==typeof define&&define.amd?define("websocket-express",[],t):"object"==typeof exports?exports["websocket-express"]=t():e["websocket-express"]=t()}(global,(function(){return function(e){var t={};function s(n){if(t[n])return t[n].exports;var o=t[n]={i:n,l:!1,exports:{}};return e[n].call(o.exports,o,o.exports,s),o.l=!0,o.exports}return s.m=e,s.c=t,s.d=function(e,t,n){s.o(e,t)||Object.defineProperty(e,t,{enumerable:!0,get:n})},s.r=function(e){"undefined"!=typeof Symbol&&Symbol.toStringTag&&Object.defineProperty(e,Symbol.toStringTag,{value:"Module"}),Object.defineProperty(e,"__esModule",{value:!0})},s.t=function(e,t){if(1&t&&(e=s(e)),8&t)return e;if(4&t&&"object"==typeof e&&e&&e.__esModule)return e;var n=Object.create(null);if(s.r(n),Object.defineProperty(n,"default",{enumerable:!0,value:e}),2&t&&"string"!=typeof e)for(var o in e)s.d(n,o,function(t){return e[t]}.bind(null,o));return n},s.n=function(e){var t=e&&e.__esModule?function(){return e.default}:function(){return e};return s.d(t,"a",t),t},s.o=function(e,t){return Object.prototype.hasOwnProperty.call(e,t)},s.p="",s(s.s=3)}([function(e,t){e.exports=require("http")},function(e,t){e.exports=require("express")},function(e,t){e.exports=require("ws")},function(e,t,s){e.exports=s(4)},function(e,t,s){"use strict";s.r(t),s.d(t,"isWebSocket",(function(){return x})),s.d(t,"Router",(function(){return S})),s.d(t,"requireBearerAuth",(function(){return y})),s.d(t,"requireAuthScope",(function(){return E})),s.d(t,"getAuthData",(function(){return v})),s.d(t,"hasAuthScope",(function(){return C}));var n=s(0),o=s.n(n),r=s(1),i=s.n(r),c=s(2),a=s.n(c);const l={};function h(e,t,s,o){if(e.writable){const r=s||n.STATUS_CODES[t],i={Connection:"close","Content-type":"text/html","Content-Length":Buffer.byteLength(r),...o};e.write([`HTTP/1.1 ${t} ${n.STATUS_CODES[t]}`,...Object.keys(i).map(e=>`${e}: ${i[e]}`),"",r].join("\r\n"))}e.destroy()}function u(e,{timeout:t=0}={}){return new Promise((s,n)=>{let o=null,r=null,i=null;const c=()=>{e.off("message",o),e.off("close",r),clearTimeout(i)};o=(e,t)=>{c(),s(void 0!==t?{data:e,isBinary:t}:"string"==typeof e?{data:Buffer.from(e,"utf8"),isBinary:!1}:{data:e,isBinary:!0})},r=()=>{c(),n()},e.on("message",o),e.on("close",r),t>0&&(i=setTimeout(r,t))})}function d(e){e.nextMessage=u.bind(null,e)}class f{constructor(e,t,s,n){this.wsServer=e,this.req=t,this.socket=s,this.head=n,this.ws=null,this.closed=!1,this.nonce=l,this.transactionNesting=0,this.closeTimeout=null,this.closeTime=0,this.closeTimeoutCode=null,this.closeTimeoutMessage=null,this.softClosing=!1,this.accept=this.accept,this.reject=this.reject,this.closeAtTime=this.closeAtTime,this.sendError=this.sendError,this.setHeader=()=>{},this.status=this.status,this.end=this.end,this.send=this.send,this.beginTransaction=this.beginTransaction,this.endTransaction=this.endTransaction,this.internalCheckCloseTimeout=this.internalCheckCloseTimeout,this.internalSoftClose=this.internalSoftClose}static isInstance(e){return e&&e.nonce===l}accept(){return this.closed?Promise.reject(new Error("Connection closed")):this.ws?Promise.resolve(this.ws):new Promise(e=>this.wsServer.handleUpgrade(this.req,this.socket,this.head,t=>{d(t),t.on("close",()=>clearTimeout(this.closeTimeout)),this.ws=t,e(this.ws)}))}reject(e=500,t=null){if(this.ws)throw new Error("Already accepted WebSocket connection");this.sendError(e,null,t)}sendError(e,t=null,s=null){if(this.closed)throw new Error("Connection closed");const o=s||n.STATUS_CODES[e];var r;this.closed=!0,this.ws?this.ws.close(t||((r=e)>=500?1011:4e3+r),o):h(this.socket,e,o)}internalCheckCloseTimeout(){if(clearTimeout(this.closeTimeout),this.closed)return;const e=Date.now();e<this.closeTime?this.closeTimeout=setTimeout(this.internalCheckCloseTimeout.bind(this),Math.min(this.closeTime-e,864e5)):(this.closed=!0,this.ws?this.ws.close(this.closeTimeoutCode,this.closeTimeoutMessage):h(this.socket,200,"Connection time limit reached"))}closeAtTime(e,t=1001,s=""){this.closed||null!==this.closeTimeout&&e>=this.closeTime||(this.closeTime=e,this.closeTimeoutCode=t,this.closeTimeoutMessage=s,this.internalCheckCloseTimeout())}status(e){if(e<400&&this.ws)throw new Error("Already accepted WebSocket connection");return this.sendError(e),this}end(){return this.ws||this.closed||this.sendError(404),this}send(e){return this.closed||(this.accept().then(t=>{t.send(e),t.close()}),this.closed=!0),this}beginTransaction(){this.transactionNesting+=1}endTransaction(){if(this.transactionNesting<=0)throw new Error("Unbalanced endTransaction");this.transactionNesting-=1,0===this.transactionNesting&&this.softClosing&&!this.closed&&this.sendError(500,1012,"server shutdown")}internalSoftClose(e){this.closed||(this.transactionNesting>0?(this.softClosing=!0,e&&this.closeAtTime(e,1012,"server shutdown")):this.sendError(500,1012,"server shutdown"))}}function p(e){return"function"!=typeof e?e:(t,s,n)=>{f.isInstance(s)?e(t,s,n):n("route")}}function m(e){return"function"!=typeof e?e:(t,s,n)=>{f.isInstance(s)?n("route"):e(t,s,n)}}function b(e,t,s){const n=e,o=n[t].bind(n);n[t]=(...e)=>o(...e.map(s))}function w(e,t=null){const s=e;t&&(s.use=t.use.bind(t),o.a.METHODS.forEach(e=>{const n=e.toLowerCase();s[n]=t[n].bind(t)}),s.all=t.all.bind(t)),s.ws=s.use,b(s,"ws",p),s.useHTTP=s.use,b(s,"useHTTP",m),o.a.METHODS.forEach(e=>{b(s,e.toLowerCase(),m)}),b(s,"all",m)}const T=["enable","enabled","disable","disabled","set","get","engine","path"];class g{constructor(...e){var t,s;this.app=i()(...e),this.locals=this.app.locals,this.wsServer=new a.a.Server({noServer:!0}),this.activeWebSockets=new WeakMap,this.app.use((e,t,s,n)=>{f.isInstance(s)&&s.sendError(500),n(e)}),this.handleUpgrade=(t=this.handleUpgrade,s=this,function(...e){return t.call(s,this,...e)}),this.handleRequest=this.handleRequest.bind(this),this.handlePreClose=this.handlePreClose.bind(this),T.forEach(e=>{this[e]=this.app[e].bind(this.app)}),w(this,this.app)}handleUpgrade(e,t,s,n){const o=new f(this.wsServer,t,s,n),r=this.activeWebSockets.get(e);return r.add(o),s.on("close",()=>r.delete(o)),this.app(t,o)}handleRequest(e,t){return this.app(e,t)}handlePreClose(e){let t=0;const s=this.app.get("shutdown timeout");"number"==typeof s&&s>=0&&(t=Date.now()+s);[...this.activeWebSockets.get(e)].forEach(e=>e.internalSoftClose(t))}attach(e){if(this.activeWebSockets.has(e))throw new Error("Cannot attach to the same server multiple times");this.activeWebSockets.set(e,new Set),function(e){if(e.close.hasPreCloseEvent)return;const t=e.close.bind(e),s=s=>{e.emit("pre-close",e),t(s)};s.hasPreCloseEvent=!0,e.close=s}(e),e.on("upgrade",this.handleUpgrade),e.on("request",this.handleRequest),e.on("pre-close",this.handlePreClose)}detach(e){this.activeWebSockets.has(e)&&(e.removeListener("upgrade",this.handleUpgrade),e.removeListener("request",this.handleRequest),e.removeListener("pre-close",this.handlePreClose),this.handlePreClose(e),this.activeWebSockets.delete(e))}createServer(){const e=o.a.createServer();return this.attach(e),e}listen(...e){return this.createServer().listen(...e)}}["static","json","urlencoded"].forEach(e=>{g[e]=(...t)=>m(i.a[e](...t)),Object.assign(g[e],i.a[e])});class S extends i.a.Router{constructor(...e){super(...e),w(this)}}function y(e,t){let s;if("string"==typeof e)s=()=>e;else{if("function"!=typeof e)throw new Error("Invalid realm; must be a string or function");s=e}return async(e,n,o)=>{const r=Math.floor(Date.now()/1e3),i=await s(e,n),c=await async function(e,t){const s=e.get("Authorization");if(s){const[e,t]=function(e,t){const s=e.indexOf(t);return-1===s?[e]:[e.substr(0,s),e.substr(s+t.length)]}(s," ");return"Bearer"===e?t:null}if(f.isInstance(t)){const e=await t.accept(),s=await e.nextMessage({timeout:5e3});if(s.isBinary)throw new Error("Token must be sent as text");return String(s.data)}return null}(e,n);let a=null;c&&(a=await t(c,i,e,n)),!a||"number"==typeof a.nbf&&r<a.nbf||"number"==typeof a.exp&&r>=a.exp?n.status(401).header("WWW-Authenticate",`Bearer realm="${i}"`).end():("number"==typeof a.exp&&f.isInstance(n)&&n.closeAtTime(1e3*a.exp,1001,"Session expired"),n.locals.authRealm=i,n.locals.authData=a,n.locals.authScopes=function(e){if(!e||"object"!=typeof e||!e.scopes)return{};const{scopes:t}=e;if(Array.isArray(t)){const e={};return t.forEach(t=>{e[t]=!0}),e}return"object"==typeof t?t:"string"==typeof t?{[t]:!0}:{}}(a),o())}}function v(e){if(!e||"object"!=typeof e||!e.locals)throw new Error("Must provide response object to getAuthData");return e.locals.authData||null}function C(e,t){if(!e||"object"!=typeof e||!e.locals)throw new Error("Must provide response object to hasAuthScope");const{authScopes:s}=e.locals;return Boolean(s&&s[t])}function E(e){return async(t,s,n)=>{const{authRealm:o}=s.locals;C(s,e)?n():s.status(403).header("WWW-Authenticate",`Bearer realm="${o}", scope="${e}"`).end()}}const x=f.isInstance;g.Router=S,g.isWebSocket=x,g.requireBearerAuth=y,g.requireAuthScope=E,g.getAuthData=v,g.hasAuthScope=C;t.default=g}])}));
//# sourceMappingURL=index.js.map