{"version":3,"sources":["webpack://websocket-express/webpack/universalModuleDefinition","webpack://websocket-express/webpack/bootstrap","webpack://websocket-express/external \"http\"","webpack://websocket-express/external \"express\"","webpack://websocket-express/external \"ws\"","webpack://websocket-express/./src/WebSocketWrapper.js","webpack://websocket-express/./src/wrapHandlers.js","webpack://websocket-express/./src/WebSocketExpress.js","webpack://websocket-express/./src/Router.js","webpack://websocket-express/./src/auth.js","webpack://websocket-express/./src/index.js"],"names":["root","factory","exports","module","define","amd","global","installedModules","__webpack_require__","moduleId","i","l","modules","call","m","c","d","name","getter","o","Object","defineProperty","enumerable","get","r","Symbol","toStringTag","value","t","mode","__esModule","ns","create","key","bind","n","object","property","prototype","hasOwnProperty","p","s","require","NONCE","bindExtraMethods","ws","nextMessage","timeout","Promise","resolve","reject","onMessage","onClose","exp","detach","off","clearTimeout","msg","on","setTimeout","WebSocketWrapper","constructor","wsServer","req","socket","head","this","closed","nonce","accept","sendError","setHeader","status","end","send","[object Object]","Error","handleUpgrade","code","message","httpStatus","wsStatus","STATUS_CODES","close","headers","writable","resolvedMessage","resolvedHeaders","Connection","Content-type","Content-Length","Buffer","byteLength","write","keys","map","h","join","destroy","abortHandshake","then","wrapWebsocket","fn","res","next","isInstance","wrapNonWebsocket","wrapHandler","method","wrapper","target","original","handlers","wrapHandlers","src","use","http","METHODS","forEach","toLowerCase","all","useHTTP","FORWARDED_EXPRESS_METHODS","WebSocketExpress","args","app","express","locals","WebSocket","Server","noServer","err","handleRequest","wrap","attach","server","removeListener","createServer","listen","middleware","Router","super","requireBearerAuth","realm","extractAndValidateToken","realmForRequest","async","authRealm","token","auth","type","data","delimiter","sep","indexOf","substr","length","splitFirst","getProvidedToken","tokenData","authData","authScopes","scopes","Array","isArray","result","scope","extractScopesMap","header","getAuthData","hasAuthScope","Boolean","requireAuthScope","__webpack_exports__","isWebSocket","Router_Router"],"mappings":"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","file":"index.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"websocket-express\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"websocket-express\"] = factory();\n\telse\n\t\troot[\"websocket-express\"] = factory();\n})(global, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 3);\n","module.exports = require(\"http\");","module.exports = require(\"express\");","module.exports = require(\"ws\");","import { STATUS_CODES } from 'http';\n\nconst NONCE = {};\n\n// Copied from https://github.com/websockets/ws/blob/master/lib/websocket-server.js#L374\nfunction abortHandshake(socket, code, message, headers) {\n  if (socket.writable) {\n    const resolvedMessage = message || STATUS_CODES[code];\n    const resolvedHeaders = {\n      Connection: 'close',\n      'Content-type': 'text/html',\n      'Content-Length': Buffer.byteLength(resolvedMessage),\n      ...headers,\n    };\n\n    socket.write([\n      `HTTP/1.1 ${code} ${STATUS_CODES[code]}`,\n      ...Object.keys(resolvedHeaders).map((h) => `${h}: ${resolvedHeaders[h]}`),\n      '',\n      resolvedMessage,\n    ].join('\\r\\n'));\n  }\n\n  socket.destroy();\n}\n\nfunction httpStatusToWs(code) {\n  if (code >= 500) {\n    return 1011;\n  }\n  return 4000 + code;\n}\n\nfunction nextMessage(ws, { timeout = 0 } = {}) {\n  return new Promise((resolve, reject) => {\n    let onMessage = null;\n    let onClose = null;\n    let exp = null;\n\n    const detach = () => {\n      ws.off('message', onMessage);\n      ws.off('close', onClose);\n      clearTimeout(exp);\n    };\n\n    onMessage = (msg) => {\n      detach();\n      resolve(msg);\n    };\n\n    onClose = () => {\n      detach();\n      reject();\n    };\n\n    ws.on('message', onMessage);\n    ws.on('close', onClose);\n    if (timeout > 0) {\n      exp = setTimeout(onClose, timeout);\n    }\n  });\n}\n\nfunction bindExtraMethods(ws) {\n  /* eslint-disable no-param-reassign */\n  ws.nextMessage = nextMessage.bind(null, ws);\n  /* eslint-enable no-param-reassign */\n}\n\nexport default class WebSocketWrapper {\n  constructor(wsServer, req, socket, head) {\n    this.wsServer = wsServer;\n    this.req = req;\n    this.socket = socket;\n    this.head = head;\n    this.ws = null;\n    this.closed = false;\n    this.nonce = NONCE;\n\n    // expressjs builds new objects using properties of response, so all methods\n    // must be explicitly added to the instance, not just the class\n    this.accept = this.accept;\n    this.reject = this.reject;\n    this.sendError = this.sendError;\n    this.setHeader = () => {}; // compatibility with expressjs (fake http.Response API)\n    this.status = this.status;\n    this.end = this.end;\n    this.send = this.send;\n  }\n\n  static isInstance(o) {\n    // expressjs builds new objects using properties of response, so we cannot\n    // rely on instanceof checks. Instead we use a nonce property:\n    return o && (o.nonce === NONCE);\n  }\n\n  accept() {\n    if (this.closed) {\n      return Promise.reject(new Error('Connection closed'));\n    }\n    if (this.ws) {\n      return Promise.resolve(this.ws);\n    }\n\n    return new Promise((resolve) => this.wsServer.handleUpgrade(\n      this.req,\n      this.socket,\n      this.head,\n      (ws) => {\n        bindExtraMethods(ws);\n        this.ws = ws;\n        resolve(this.ws);\n      },\n    ));\n  }\n\n  reject(code = 500, message = null) {\n    if (this.ws) {\n      throw new Error('Already accepted WebSocket connection');\n    }\n    this.sendError(code, null, message);\n  }\n\n  sendError(httpStatus, wsStatus = null, message = null) {\n    if (this.closed) {\n      throw new Error('Connection closed');\n    }\n\n    const msg = message || STATUS_CODES[httpStatus];\n\n    this.closed = true;\n    if (this.ws) {\n      this.ws.close(wsStatus || httpStatusToWs(httpStatus), msg);\n    } else {\n      abortHandshake(this.socket, httpStatus, msg);\n    }\n  }\n\n  status(code) {\n    if (code < 400 && this.ws) {\n      throw new Error('Already accepted WebSocket connection');\n    }\n    this.sendError(code);\n    return this;\n  }\n\n  end() {\n    if (!this.ws && !this.closed) {\n      this.sendError(404);\n    }\n    return this;\n  }\n\n  send(message) {\n    if (!this.closed) {\n      this.accept().then((ws) => {\n        ws.send(message);\n        ws.close();\n      });\n      this.closed = true;\n    }\n    return this;\n  }\n}\n","import http from 'http';\nimport WebSocketWrapper from './WebSocketWrapper';\n\nfunction wrapWebsocket(fn) {\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n  return (req, res, next) => {\n    if (WebSocketWrapper.isInstance(res)) {\n      fn(req, res, next);\n    } else {\n      next('route');\n    }\n  };\n}\n\nexport function wrapNonWebsocket(fn) {\n  if (typeof fn !== 'function') {\n    return fn;\n  }\n  return (req, res, next) => {\n    if (WebSocketWrapper.isInstance(res)) {\n      next('route');\n    } else {\n      fn(req, res, next);\n    }\n  };\n}\n\nfunction wrapHandler(o, method, wrapper) {\n  const target = o;\n  const original = target[method].bind(target);\n  target[method] = (...handlers) => original(...handlers.map(wrapper));\n}\n\nexport default function wrapHandlers(o, src = null) {\n  const target = o;\n\n  if (src) {\n    target.use = src.use.bind(src);\n    http.METHODS.forEach((method) => {\n      const name = method.toLowerCase();\n      target[name] = src[name].bind(src);\n    });\n    target.all = src.all.bind(src);\n  }\n\n  target.ws = target.use;\n  wrapHandler(target, 'ws', wrapWebsocket);\n\n  target.useHTTP = target.use;\n  wrapHandler(target, 'useHTTP', wrapNonWebsocket);\n\n  http.METHODS.forEach((method) => {\n    wrapHandler(target, method.toLowerCase(), wrapNonWebsocket);\n  });\n\n  wrapHandler(target, 'all', wrapNonWebsocket);\n}\n","import http from 'http';\nimport express from 'express';\nimport WebSocket from 'ws';\nimport WebSocketWrapper from './WebSocketWrapper';\nimport wrapHandlers, { wrapNonWebsocket } from './wrapHandlers';\n\nconst FORWARDED_EXPRESS_METHODS = [\n  'enable',\n  'enabled',\n  'disable',\n  'disabled',\n  'set',\n  'get',\n  'engine',\n  'path',\n];\n\nconst FORWARDED_HTTP_MIDDLEWARE = [\n  'static',\n  'json',\n  'urlencoded',\n];\n\nexport default class WebSocketExpress {\n  constructor(...args) {\n    this.app = express(...args);\n    this.locals = this.app.locals;\n    this.wsServer = new WebSocket.Server({ noServer: true });\n\n    this.app.use((err, req, res, next) => {\n      // error handler: close web socket\n      if (WebSocketWrapper.isInstance(res)) {\n        res.sendError(500);\n      }\n      next(err);\n    });\n\n    this.handleUpgrade = this.handleUpgrade.bind(this);\n    this.handleRequest = this.handleRequest.bind(this);\n\n    FORWARDED_EXPRESS_METHODS.forEach((method) => {\n      this[method] = this.app[method].bind(this.app);\n    });\n\n    wrapHandlers(this, this.app);\n  }\n\n  handleUpgrade(req, socket, head) {\n    const wrap = new WebSocketWrapper(this.wsServer, req, socket, head);\n    return this.app(req, wrap);\n  }\n\n  handleRequest(req, res) {\n    return this.app(req, res);\n  }\n\n  attach(server) {\n    server.on('upgrade', this.handleUpgrade);\n    server.on('request', this.handleRequest);\n  }\n\n  detach(server) {\n    server.removeListener('upgrade', this.handleUpgrade);\n    server.removeListener('request', this.handleRequest);\n  }\n\n  createServer() {\n    const server = http.createServer();\n    this.attach(server);\n    return server;\n  }\n\n  listen(...args) {\n    const server = this.createServer();\n    return server.listen(...args);\n  }\n}\n\nFORWARDED_HTTP_MIDDLEWARE.forEach((middleware) => {\n  WebSocketExpress[middleware] = (...args) => wrapNonWebsocket(\n    express[middleware](...args),\n  );\n});\n","import express from 'express';\nimport wrapHandlers from './wrapHandlers';\n\nexport default class Router extends express.Router {\n  constructor(...args) {\n    super(...args);\n    wrapHandlers(this);\n  }\n}\n","import WebSocketWrapper from './WebSocketWrapper';\n\nfunction splitFirst(data, delimiter) {\n  const sep = data.indexOf(delimiter);\n  if (sep === -1) {\n    return [data];\n  }\n  return [data.substr(0, sep), data.substr(sep + delimiter.length)];\n}\n\nasync function getProvidedToken(req, res) {\n  const auth = req.get('Authorization');\n  if (auth) {\n    const [type, data] = splitFirst(auth, ' ');\n\n    if (type === 'Bearer') {\n      return data;\n    }\n\n    return null;\n  }\n\n  if (WebSocketWrapper.isInstance(res)) {\n    const ws = await res.accept();\n    return ws.nextMessage({ timeout: 5000 });\n  }\n\n  return null;\n}\n\nfunction extractScopesMap(data) {\n  if (!data || typeof data !== 'object' || !data.scopes) {\n    return {};\n  }\n  const { scopes } = data;\n  if (Array.isArray(scopes)) {\n    const result = {};\n    scopes.forEach((scope) => {\n      result[scope] = true;\n    });\n    return result;\n  }\n  if (typeof scopes === 'object') {\n    return scopes;\n  }\n  if (typeof scopes === 'string') {\n    return { [scopes]: true };\n  }\n  return {};\n}\n\nexport function requireBearerAuth(realm, extractAndValidateToken) {\n  let realmForRequest;\n  if (typeof realm === 'string') {\n    realmForRequest = () => realm;\n  } else if (typeof realm === 'function') {\n    realmForRequest = realm;\n  } else {\n    throw new Error('Invalid realm; must be a string or function');\n  }\n\n  return async (req, res, next) => {\n    const authRealm = await realmForRequest(req, res);\n    const token = await getProvidedToken(req, res);\n\n    let tokenData = null;\n    if (token) {\n      tokenData = await extractAndValidateToken(token, authRealm, req, res);\n    }\n\n    if (!tokenData) {\n      res\n        .status(401)\n        .header('WWW-Authenticate', `Bearer realm=\"${authRealm}\"`)\n        .end();\n      return;\n    }\n\n    res.locals.authRealm = authRealm;\n    res.locals.authData = tokenData;\n    res.locals.authScopes = extractScopesMap(tokenData);\n\n    next();\n  };\n}\n\nexport function getAuthData(res) {\n  if (!res || typeof res !== 'object' || !res.locals) {\n    throw new Error('Must provide response object to getAuthData');\n  }\n  return res.locals.authData || null;\n}\n\nexport function hasAuthScope(res, scope) {\n  if (!res || typeof res !== 'object' || !res.locals) {\n    throw new Error('Must provide response object to hasAuthScope');\n  }\n  const { authScopes } = res.locals;\n  return Boolean(authScopes && authScopes[scope]);\n}\n\nexport function requireAuthScope(scope) {\n  return async (req, res, next) => {\n    const { authRealm } = res.locals;\n    if (!hasAuthScope(res, scope)) {\n      res\n        .status(403)\n        .header(\n          'WWW-Authenticate',\n          `Bearer realm=\"${authRealm}\", scope=\"${scope}\"`,\n        )\n        .end();\n      return;\n    }\n    next();\n  };\n}\n","import WebSocketExpress from './WebSocketExpress';\nimport WebSocketWrapper from './WebSocketWrapper';\nimport Router from './Router';\nimport {\n  requireBearerAuth,\n  requireAuthScope,\n  getAuthData,\n  hasAuthScope,\n} from './auth';\n\nexport const isWebSocket = WebSocketWrapper.isInstance;\n\nWebSocketExpress.Router = Router;\nWebSocketExpress.isWebSocket = isWebSocket;\nWebSocketExpress.requireBearerAuth = requireBearerAuth;\nWebSocketExpress.requireAuthScope = requireAuthScope;\nWebSocketExpress.getAuthData = getAuthData;\nWebSocketExpress.hasAuthScope = hasAuthScope;\n\nexport default WebSocketExpress;\nexport {\n  Router,\n  requireBearerAuth,\n  requireAuthScope,\n  getAuthData,\n  hasAuthScope,\n};\n"],"sourceRoot":""}